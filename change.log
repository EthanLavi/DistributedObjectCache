+109 rdma/include/rome/rdma/rdma_ptr.h
const rdma_ptr operator[](int index) const {
  rdma_ptr new_ptr = *this;
  new_ptr += index;
  return new_ptr;
}

+115 workload/include/remus/workload/workload_driver.h
template <typename T> class TimedStream : public Stream<T> {
public:
  TimedStream(std::function<T(void)> generator, int in_seconds) : generator_(generator) {
    std::chrono::seconds seconds = duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch());
    stop_time_ = seconds + std::chrono::seconds(in_seconds);
  }

private:
  std::function<T(void)> generator_;
  std::chrono::seconds stop_time_;
  inline util::StatusVal<T> NextInternal() override {
    std::chrono::seconds now = duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch());
    if (now > stop_time_){
      return {StreamTerminatedStatus(), {}};
    }
    return {util::Status::Ok(), generator_()};
  }
};

+303 rdma/include/remus/rdma/memory_pool.h
template <typename T> void Write(rdma_ptr<T> ptr, const T &val, rdma_ptr<T> prealloc = nullptr, RDMAWriteBehavior write_behavior = RDMAWriteWithAck) {

+340 rdma/include/remus/rdma/memory_pool.h
send_wr_.send_flags = IBV_SEND_FENCE;
send_wr_.wr.rdma.remote_addr = ptr.address();
send_wr_.wr.rdma.rkey = info.rkey;

// set the counter to the number of work completions we expect
if (write_behavior == RDMAWriteWithAck) {
  send_wr_.send_flags |= IBV_SEND_SIGNALED;
  // set the counter to the number of work completions we expect
  reordering_counters[index_as_id] = 1;
}

+183 rdma/include/remus/rdma/rdma.h
/// Write to an RDMA heap
template <typename T> void Write(rdma_ptr<T> ptr, const T &val, rdma_ptr<T> prealloc = nullptr, internal::RDMAWriteBehavior write_behavior = internal::RDMAWriteWithAck) {
  pool.Write(ptr, val, prealloc, write_behavior);
}

+20 rdma/include/remus/rdma/memory_pool.h
enum RDMAWriteBehavior {
  RDMAWriteWithAck = 0,
  RDMAWriteWithNoAck = 1,
};

+168 workload/include/remus/workload/workload_driver.h
/// A simple workload driver
///
/// This workload driver
// For reference, a `WorkloadDriver` with a simple `MappedStream` (i.e.,
// consisting of one sub-stream) can achieve roughly 1M QPS. This was measured
// using a client adapter that does nothing. As the number of constituent
// streams increases, we expect the maximum throughput to decrease but it is
// not likely to be the limiting factor in performance.
template <template <typename> typename ClientAdapter, typename OpType> class WorkloadDriver {
  std::unique_ptr<ClientAdapter<OpType>> client_;
  std::unique_ptr<Stream<OpType>> stream_;

  metrics::Counter<uint64_t> ops_;
  std::unique_ptr<metrics::Stopwatch> stopwatch_;

  uint64_t prev_ops_;
  std::chrono::milliseconds qps_sampling_rate_;
  metrics::Summary<double> qps_summary_;

  std::chrono::milliseconds lat_sampling_rate_;
  metrics::Summary<double> lat_summary_;

public:
  WorkloadDriver(std::unique_ptr<ClientAdapter<OpType>> client, 
                std::unique_ptr<Stream<OpType>> stream,
                std::chrono::milliseconds qps_sampling_rate)
    : client_(std::move(client)), stream_(std::move(stream)), ops_("total_ops"),
      stopwatch_(nullptr), prev_ops_(0), qps_sampling_rate_(qps_sampling_rate),
      qps_summary_("sampled_qps", "ops/s", 1000), lat_sampling_rate_(10), lat_summary_("sampled_lat", "ns", 1000) {}

  metrics::Stopwatch *GetStopwatch() { return stopwatch_.get(); }

  std::string ToString() {
    std::stringstream ss;
    ss << ops_ << std::endl;
    ss << lat_summary_ << std::endl;
    ss << qps_summary_ << std::endl;
    ss << *stopwatch_;
    return ss.str();
  }

  metrics::WorkloadDriverResult ToMetrics() {
    metrics::WorkloadDriverResult result;
    result.ops = ops_.ToMetrics();
    result.runtime = stopwatch_->ToMetrics();
    result.qps = qps_summary_.ToMetrics();
    result.latency = lat_summary_.ToMetrics();
    return result;
  }

  [[deprecated("Use ToMetrics() instead")]] WorkloadDriverProto ToProto() {
    WorkloadDriverProto proto;
    proto.mutable_ops()->CopyFrom(ops_.ToProto());
    proto.mutable_runtime()->CopyFrom(stopwatch_->ToProto());
    proto.mutable_qps()->CopyFrom(qps_summary_.ToProto());
    proto.mutable_latency()->CopyFrom(lat_summary_.ToProto());
    return proto;
  }

  util::Status Run() {
    auto status = client_->Start();
    if (status.t != util::Ok)
      return status;
    stopwatch_ = metrics::Stopwatch::Create("driver_stopwatch");

    while (true) {
      auto next_op = stream_->Next();
      if (next_op.status.t != util::Ok) {
        if (!IsStreamTerminated(next_op.status)) {
          status = next_op.status;
        }
        break;
      }

      auto curr_lap = stopwatch_->GetLapSplit();
      auto curr_lap_ms = std::chrono::duration_cast<std::chrono::milliseconds>(curr_lap.GetRuntimeNanoseconds());

      auto client_status = client_->Apply(next_op.val.value());
      if (curr_lap_ms > lat_sampling_rate_) {
        lat_summary_ << (stopwatch_->GetLapSplit().GetRuntimeNanoseconds().count() -
                         curr_lap.GetRuntimeNanoseconds().count());
      }

      if (client_status.t != util::Ok) {
        status = client_status;
        break;
      }

      ++ops_;

      if (curr_lap_ms > qps_sampling_rate_) {
        auto curr_ops = ops_.GetCounter();
        auto sample = (curr_ops - prev_ops_) / (stopwatch_->GetLap().GetRuntimeNanoseconds().count() * 1e-9);
        qps_summary_ << sample;
        prev_ops_ = curr_ops;
      }
    }
    // Once we leave the loop, we've reached the end of our stream and can stop the client
    status = client_->Stop();
    stopwatch_->Stop();
    return status;
  }
};

- examples/iht (Deleted directory)

+ In memory_pool.h
if (conn_info_.find(ptr.id()) == conn_info_.end()) REMUS_ERROR("Cannot find {} as a node ID", ptr.id());
auto info = conn_info_.at(ptr.id());

// [esl] Getting the thread's index to determine it's owned flag
if (this->thread_ids.find(std::this_thread::get_id()) == this->thread_ids.end()) 
  REMUS_ERROR("Cannot find a thread ID. Make sure to call Register thread");
uint64_t index_as_id = this->thread_ids.at(std::this_thread::get_id());

Also made the rdma_capability_thread edit

+ In memory_pool.h
Line 117, memset is a bug, should be bytes
changed comparison from >= to p->first == bytes
also the deallocation has (bytes, ptr);